# V8 浅度学习

过去 JS 性能显著提升的主要原因是执行机制由解释变为 JIT（Just In Time）。

现代 JS 引擎的执行过程一般为：源代码 => 抽象语法树（AST） => 字节码（bytecode） => JIT => Native code。

V8 引擎稍有不同，去掉了生成字节码的过程，直接将抽象语法树通过 JIT 转换为 native code，放弃了在字节码阶段可以进行的一些性能优化，保证了 JS 的执行速度。后续 V8 引擎为了弥补直接跳过字节码阶段带来的性能问题，会通过 Profiler 采集信息来优化 native code。

V8 实际上使用两个不同的 JS 编译器：Full Compiler 是一个没有优化过程的编译器，其主要工作是尽可能快地生成 native  code 来保证页面能够快速加载；Crankshaft 是一个具备优化功能的编译器。V8 在编译过程中，首先使用 Full Compiler 快速生成 native code，然后使用内建的 profiler（性能分析器）挑选出高频函数，抛给 Crankshaft 进行优化。

那么为什么要这么设计呢？V8 引擎基本上是单线程运行的，任何一个编译器的运行都会阻塞 JS 的执行。所以编译器应该快速处理代码，而不是把时间花在代码的性能优化上。在未来，Crankshaft 会在一个独立的线程中运行，与 JS 的执行并发，以便进行更多优化。

大部分虚拟机都包含字节码解释器，但这在 V8 引擎上被摒弃了。实际上直接编译为未优化的 native code 和编译为字节码这两个过程，消耗的资源都是接近的，但是对于 JS 执行来说，明显 V8 引擎是更快的。